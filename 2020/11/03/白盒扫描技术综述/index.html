<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>白盒扫描技术简介 | Fr4nk404</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">白盒扫描技术简介</h1><a id="logo" href="/.">Fr4nk404</a><p class="description">Fr4nk404's Bl0g</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">白盒扫描技术简介</h1><div class="post-meta">Nov 3, 2020<span> | </span><span class="category"><a href="/categories/Security/">Security</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2020/11/03/白盒扫描技术综述/" href="/2020/11/03/白盒扫描技术综述/#disqus_thread"></a><div class="post-content"><p>静态程序分析技术在白盒扫描中应用广泛，简要记录下相关的分析技术。</p>
<h3 id="词法分析技术"><a href="#词法分析技术" class="headerlink" title="词法分析技术"></a>词法分析技术</h3><p>词法分析技术是最简单的一类漏洞挖掘技术，其主要思想是将代码文本与归纳好的缺陷模式进行匹配，以此发现漏洞。由于其不深入分析程序结构和语义，往往只能挖掘较为简单的一类漏洞，并且存在相当高的误报率，在实际场景下应用较少，但由于其思想简单，适用性很广，目前也还存在类似工具，如：<a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF" target="_blank" rel="noopener">MobSF</a>，<a href="https://github.com/WhaleShark-Team/cobra" target="_blank" rel="noopener">Cobra</a>等。</p>
<h3 id="语法分析技术"><a href="#语法分析技术" class="headerlink" title="语法分析技术"></a>语法分析技术</h3><p>语法分析技术是一个把单词组合成句子的过程，在静态程序片段中可以通过AST解析实现变量传递，进一步进行污点分析。正如在词法分析中使用正则表达式来描述词法的规则一样，语法分析使用一种比正则表达能力更强的工具上下文无关文法，来描述语言的语法规则。语法分析可以将某一种语言看成无数个符合语法规则句子的集合。根据给定的上下文无关文法我们可以判断某一个 Token 串是否符合某个语法规则；如果符合，那么可以把此文法和对应输入的 Token 串组合起来生成一个句子。</p>
<h3 id="语义分析技术"><a href="#语义分析技术" class="headerlink" title="语义分析技术"></a>语义分析技术</h3><p>语义分析技术是通过对结构上正确的源程序进行上下文有关性质的审查，进行类型审查，从而分析程序中不安全的函数及方法使用所存在的安全问题。语义分析通过审查源程序有无语义错误，为代码生成阶段收集类型信息。在白盒扫描应用中，当词法分析技术将代码片段转化成Token流，语法分析完成AST解析进行变量追踪的过程中，语义分析可以完善前两者带来的误报问题，在代码语义层面进行深入理解实现降噪。</p>
<h3 id="形式化方法分析技术"><a href="#形式化方法分析技术" class="headerlink" title="形式化方法分析技术"></a>形式化方法分析技术</h3><p>形式化方法分析主要思想是将软件代码性质进行形式化描述，再判断该描述是否满足漏洞特征的一类<a href="https://link.springer.com/book/10.1007/978-3-662-22646-9" target="_blank" rel="noopener">分析方法</a>，其中定理证明技术是形式化代码分析技术的主要代表。定理证明技术将漏洞存在（或不存在）定义为一定理，再将源程序代码特征转化为数学表达形式，最后对数学表达进行逻辑推理，若定理存在性得以证明，则漏洞存在（或不存在），即漏洞挖掘过程类似于数学上的定理证明过程。主要代表性工具有 <a href="https://fbinfer.com/" target="_blank" rel="noopener">infer</a>、 <a href="https://www.cs.utexas.edu/~isil/cs389L/esc-pldi02.pdf" target="_blank" rel="noopener">ESC/Java</a> 和 <a href="https://theory.stanford.edu/~aiken/publications/papers/saturn_toplas.pdf" target="_blank" rel="noopener">saturn</a>。</p>
<p>该技术作为一种使用严格数理逻辑推理作为检测手段的技术，误报率较低，但由于其需要针对特定漏洞构建数学条件，需要大量人工参与，有的漏洞甚至难以用数学结构表达，目前只适用于死循环、资源泄露和空指针等问题，对新漏洞的扩展性不高，同时，如何将大规模程序应用于形式化方法分析也成为工业界亟待解决的问题。</p>
<p>对于形式化分析技术本人也不是很了解，想要进一步了解的建议看下<a href="https://link.springer.com/book/10.1007/978-3-662-22646-9" target="_blank" rel="noopener">文章</a>和<a href="https://github.com/leanprover/lean2" target="_blank" rel="noopener">lean2</a>。</p>
<h3 id="符号执行技术"><a href="#符号执行技术" class="headerlink" title="符号执行技术"></a>符号执行技术</h3><p>符号执行技术是一种将程序执行可达性问题转化为约束求解问题，并以此进行漏洞挖掘的<a href="https://people.eecs.berkeley.edu/~ksen/papers/cacm13.pdf" target="_blank" rel="noopener">技术</a>，代表性工具有<a href="http://angr.io/" target="_blank" rel="noopener">angr</a>，<a href="https://web.eecs.umich.edu/~weimerw/2014-6610/reading/p213-godefroid.pdf" target="_blank" rel="noopener">DART</a>, <a href="http://mir.cs.illinois.edu/marinov/publications/SenETAL05CUTE.pdf" target="_blank" rel="noopener">CUTE</a>, <a href="https://web.stanford.edu/~engler/exe-ccs-06.pdf" target="_blank" rel="noopener">EXE</a>和<a href="https://hci.stanford.edu/cstr/reports/2008-03.pdf" target="_blank" rel="noopener">KLEE</a>。</p>
<p>具体来说，符号执行包含一个符号状态表 $σ$ 和一个符号路径约束 $PC$。开始时，$σ=∅, PC=true$，每读取一条语句，就将变量抽象为约束求解中的变量、常量或他们的表达式放入 $σ$ 中，特别的，当遇到条件判断 $if(e)$ 时，将if分支的 $PC$ 更新为 $PC ← σ(e)$，将else分支的 $PC’$ 更新为 $PC←~σ(e)$，随后使用约束求解器求解 $PC$ 和 $PC’$，如果约束不满足，则停止对该分支的解析（因为该分支不可达）。当符号执行遇到程序崩溃、预先定义的漏洞语句、或是程序正常退出时，整个分析停止，同时可以计算可以到达停止点的输入。</p>
<p>符号执行可以分析程序中的控制流、覆盖更多代码，同时也有效降低了误报率，但传统符号执行严重依赖于约束求解器的能力，例如，若约束求解器不能处理非线性计算，或是整个程序中存在无法分析的第三方库，那么整个分析将无法继续。为解决这些问题，研究者们提出了动态符号执行的想法，但其在实际应用中仍不是很广泛，主要原因在于其需要大量计算资源，甚至在处理大规模程序时，出现的路径爆炸问题会导致约束求解无法产生结果。</p>
<p>符号执行技术是目前工业界和企业界都在研究的热门领域，这里推荐看下符号执行的经典文章<a href="https://people.eecs.berkeley.edu/~ksen/papers/cacm13.pdf" target="_blank" rel="noopener">“Symbolic Execution for Software Testing: Three Decades Later”</a>，还有wcventure大佬总结的<a href="https://blog.csdn.net/wcventure/article/details/86773290" target="_blank" rel="noopener">这篇文章</a>。</p>
<h3 id="数据流和控制流分析技术"><a href="#数据流和控制流分析技术" class="headerlink" title="数据流和控制流分析技术"></a>数据流和控制流分析技术</h3><p>数据流分析是一种按程序执行路径模拟数据流动的一种分析技术，其原本用于进行<a href="https://courses.cs.washington.edu/courses/cse501/15sp/papers/kildall.pdf" target="_blank" rel="noopener">程序优化</a>，安全研究者们发现后将其运用于漏洞挖掘中，如今该技术在白盒，灰盒和黑盒测试都有<a href="https://www.sec.cs.tu-bs.de/pubs/2016a-dimva.pdf" target="_blank" rel="noopener">应用</a>。</p>
<p>在数据流分析过程中，存在过程内分析和过程间分析，过程内分析主要对函数内分析，而过程间分析主要处理跨函数分析。</p>
<p>对于过程内分析，根据其对程序路径的分析精度，可分为流不敏感分析，流敏感分析和路径敏感分析。流不敏感的数据流分析只是按代码行号从上而下进行分析；流敏感分析会首先产生程序控制流图（CFG, Control Flow Graph），再按照CFG的拓扑排序正向或逆向分析；路径敏感信息不仅考虑到语句先后顺序，还会考虑语句可达性，即会沿实际可执行到路径进行分析。</p>
<p>过程间分析，首先构造程序的调用图（CG, Call Graph），接着遍历图中函数进行过程内分析，当遇到其他函数时，若已分析过，则直接使用分析结果向下分析，若未分析过，则跟进该函数，再次进行过程内分析，并且将分析结果保存。</p>
<p>数据流分析能够一定程度上理解程序语义，是一种比词法分析技术更为精确的一类分析技术，其关键在于准确计算程序的数据流。</p>
<h3 id="污点分析技术"><a href="#污点分析技术" class="headerlink" title="污点分析技术"></a>污点分析技术</h3><p>污点分析属于数据流分析的变种，通过判断关键操作的数据（如调用危险函数的参数）是否可被用户操控，推测程序是否存在安全性漏洞。由于其了解程序上下文，并且有较强的可解释性——安全工程师可以通过跟踪污点传播过程判断是否存在安全问题，因此其也成为了挖掘 Web 或 Android 漏洞较为常用的技术，也被很多开源或商用白盒扫描器使用，如：<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.92.3761&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener">Pixy</a>、Find Security Bugs、Fortify和LGTM。</p>
<h4 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h4><p>污点分析主要有三个组成要素：污点信息产生点（source）、污点信息汇聚点（sink）和污点信息清洁点（sanitizer），它们通常需要富有经验的安全工程师手动设置。</p>
<ul>
<li>污点源（source）：污点产生点往往是用户输入的数据，比如Web应用中读取URL参数的函数，顾名思义，这些函数调用后的返回值被标记为污点——攻击者可以操控的数据点。</li>
<li>汇聚点（sink）：检查点是程序的一些敏感操作，如调用数据库查询语句，或是将数据返回到网页，如果这些操作的数据是污点，那么意味着操作可被攻击者利用，即程序存在漏洞。</li>
<li>无害处理（sanitizer）：清洁点通常是对污点进行消除的一类操作，如SQL注入、XSS中的过滤函数。清洁点是污点传播准确性的重要保证，不能识别清洁点即会引发污点过污染问题。</li>
</ul>
<h4 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h4><p>污点分析分为静态污点分析和动态污点分析，两者区别在于静态污点分析只使用程序代码模拟污点传播过程，而动态污点传播则通过程序的实际运行进行传播，由于本文关注于白盒测试情景，故只介绍静态污点传播方法。<br>在定义好三要素之后，污点分析法会与数据流分析一样，对程序进行过程内分析和过程间分析。过程内分析包括了显式流分析和隐式流分析，显示流分析即通过分析变量的数据依赖关系进行污点传播，而隐式分析则是指考虑控制依赖进行污点传播。</p>
<p><img src="/2020/11/03/白盒扫描技术综述/1.png" alt="static_analysis"><br>如上图所示，首先假设变量 $a 为污点变量，实线箭头表示了显示污点传播路径，而虚线箭头表示了隐式污点传播路径，同时该图也说明了过程内污点传播基本思想，即从上至下遍历数据流图，若未标记的变量依赖于污点变量，则新变量也被标记为污点变量。虽然攻击者确实可以利用控制依赖操作数据进行攻击，但由于其分析复杂且会产生大量误报，在工程领域常常只做数据流依赖的显示分析，因此本文主要讨论显式流分析。</p>
<p>现代程序存在着复杂的函数调用，除了进行过程内分析，还需要进行过程间分析。其分析首先构造函数调用图（Call Graph），接着搜索存在产生点的函数，对于每一个存在产生点的函数，自顶向下分析（也可以自底向上分析）。遇到函数调用时，跟进被调函数，进行过程内污点分析，将分析结果表达为 &lt;func,{a,b,c},1&gt; 的函数摘要，其中$f$包含函数本身摘要信息（类名方法名和函数签名），$S$ 指调用过该函数后被污染的变量集合，$r$ 取值0或1，标记函数返回值是否被污染；接着根据函数摘要，再进行过程内分析，如此往复直至分析完函数所有代码块或是污点传播至汇聚点，报告漏洞。</p>
<p><img src="/2020/11/03/白盒扫描技术综述/2.png" alt="taint_propagation"><br>如上图所示，分析过程从左侧函数开始，因为其找到了一处产生点——request.getParameter(“xss”)，于是将污点传递到变量p，接着调用函数func(p)，于是对函数func()做过程内分析，得到其函数摘要,&lt;func,{a,b,c},1&gt;，于是回到调用者的函数内，变量q被标记为污点，又因为第三行存在一处汇聚点——response.getpriter.print()，并且参数为污点，于是报告此处有漏洞，并且根据汇聚点可以判断该漏洞是一个 XSS 漏洞。</p>
<h4 id="优势和不足"><a href="#优势和不足" class="headerlink" title="优势和不足"></a>优势和不足</h4><p>污点分析能够对程序上下文有一定理解，往往能产生误报率相对较低以及可解释的漏洞报告，其方法对 Web 类型的安全漏洞覆盖率较高，而污点类型的漏洞普遍具有较高危害性，因此该方法已被很多工业界、学术界的安全静态扫描工具所使用。</p>
<p>然而，污点传播仍有可能发生误报，以下通过简单示例来说明。</p>
<p><img src="/2020/11/03/白盒扫描技术综述/3.png" alt="false_positives"><br>首先，污点传播对容器类型无法做很好处理，如上图 (a)所示，当污点传入 容器类型时（在此例子中为 map），静态污点传播只能将这类变量的传播规则设 为传播/不传播污点，从而造成过污染/欠污染，就如图所示，若设为 map 传播污点，由于案例实际从容器中取出的是没有污点的变量，即过污染，而若设为不传播，若 q 取出参数 p，那么又导致欠污染。动态污点传播虽然解决了这一问题， 但是由于其使用条件复杂，且无法用于静态分析，本文暂不讨论。</p>
<p>此外，不论是动态污点传播还是静态污点传播，其对污点清洁点的识别能力几乎为零，如上图(b)所示，该函数是一个典型的防御 SQL 注入的污点清洁 函数，即在第 2∼5 行对待拼接 SQL 字符串存在的特殊字符进行替换和过滤，但 是污点传播并不能识别这些清洁函数，导致误报。</p>
<p>再者，静态污点传播对控制流没法做很好的处理，如上图(c)所示，在第三行，程序已经对可能产生的SSRF漏洞进行了处理，即如果是内部地址则直接返回，但是不论是考虑显式流还是隐式流，污点传播都不能避免这一类误报。</p>
<p>最后，对于特殊触发条件的漏洞，污点传播无法很好处理，如上图(d)所示，在第二行，因为SSRF要求攻击者能够操控主机名，所以即使用户输入的污点变量拼接在一个正常主机名之后，程序也不会出现SSRF，而按照污点传播分析法，毫无疑问它会报告这段程序存在 SSRF 漏洞。</p>
<p>这些问题也是工业界和学术界亟待解决的问题，如工业界开始尝试用符号执行，以及用黑盒、IAST配合解决白盒，在学术界也正尝试用机器学习解决问题。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ol>
<li>J. M. Schumann, Automated Theorem Proving in Software Engineering, Springer Berlin Heidelberg, Berlin, Heidelberg, 2001.</li>
<li>C. Flanagan, K. R. M. Leino, M. Lillibridge, G. Nelson, J. B. Saxe, R. Stata, Extended static checking for Java, in: Proceedings of the 2002 ACM SIGPLAN Conference on Programming Language Design and Implementation, Vol. 48, ACM Press, New York, New York, USA, 2002, pp. 234–245.</li>
<li>Y. Xie, A. Aiken, Saturn: A scalable framework for error detection using Boolean satisfiability, ACM Transactions on Programming Languages and Systems 29 (3) (2007) 16</li>
<li>C. Cadar, K. Sen, Symbolic Execution for Software Testing: Three Decades Later, Communications of the ACM 56 (2) (2013) 82–90.</li>
<li>P. Godefroid, N. Klarlund, K. Sen, DART: directed automated random testing, in: Proceedings of the 2005 ACM SIGPLAN conference on Programming language design and implementation, Vol. 40, ACM Press, New York, New York, USA, 2005, pp. 213–223.</li>
<li>K. Sen, D. Marinov, G. Agha, CUTE: a concolic unit testing engine for C, Proceedings of the 10th European software engineering conference held jointly with 13th ACM SIGSOFT international symposium on Foundations of software engineering 30 (5) (2005) 263.</li>
<li>C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill, D. R. Engler, EXE: Automatically Generating Inputs of Death, ACM Transactions on Information and System Security 12 (2) (2008) 1–38.</li>
<li>C. Cadar, D. Dunbar, D. Engler, Klee: Unassisted and automatic generation of high­coverage tests for complex systems programs, in: Proceedings of the 8th USENIX Symposium on Operating Systems Design and Implementation, OSDI 2008, Vol. 8, 2019, pp. 209–224</li>
<li>G. A. Kildall, A unified approach to global program optimization, in: Proceedings of the 1st annual ACM SIGACT SIGPLAN symposium on Principles of programming languages, ACM Press, New York, New York, USA, 1973, pp. 194–206.</li>
<li>B. Shastry, F. Yamaguchi, K. Rieck, J. P. Seifert, Towards Vulnerability Discovery Using Staged Program Analysis, in: Detection of Intrusions and Malware, and Vulnerability Assessment, Springer, Cham, 2016, pp. 78–97.</li>
<li>N. Jovanovic, C. Kruegel, E. Kirda, Pixy: a static analysis tool for detecting Web application vulnerabilities, in: Proceedings of the 2006 IEEE Symposium on Security and Privacy, IEEE, 2006, pp. 258–263.</li>
<li>白盒扫描技术综述[EB/OL], <a href="https://f5.pm/go-27538.html" target="_blank" rel="noopener">https://f5.pm/go-27538.html</a></li>
<li>简单理解符号执行技术[EB/OL], <a href="https://dwz1.cc/WPMjO87q" target="_blank" rel="noopener">https://dwz1.cc/WPMjO87q</a></li>
<li>PHP 开源白盒审计工具初探[EB/OL], <a href="https://dwz1.cc/HdEVRrmG" target="_blank" rel="noopener">https://dwz1.cc/HdEVRrmG</a></li>
</ol>
</div><iframe src="/donate/?AliPayQR=img/alipay.jpg&amp;WeChatQR=img/wechat.jpg&amp;GitHub=https://github.com/fr4nk404&amp;BTCQR=img/btc.jpg&amp;BTCKEY=1DgCePEwFFHwJm9bmAiv1rpgtp8AqGw3aq&amp;PayPal=undefined" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>fr4nk404</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2020/11/03/白盒扫描技术综述/">https://fr4nk404.github.io/2020/11/03/白盒扫描技术综述/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>Copyright © 2019 fr4nk404's Blog. Powered by Hexo. Theme by Cho.</li></ul></div><br><div class="tags"></div><div class="post-nav"><a class="next" href="/2020/10/25/反射放大DDos/">反射放大DDoS</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://fr4nk404.github.io/2020/11/03/白盒扫描技术综述/';
    this.page.identifier = '2020/11/03/白盒扫描技术综述/';
    this.page.title = '白盒扫描技术简介';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//Fr4nk404.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//Fr4nk404.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://Fr4nk404.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://fr4nk404.github.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Daily/">Daily</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Interesting/">Interesting</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Security/">Security</a><span class="category-list-count">7</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/VulnExploit/" style="font-size: 15px;">VulnExploit</a> <a href="/tags/bb/" style="font-size: 15px;">bb</a> <a href="/tags/DailyUse/" style="font-size: 15px;">DailyUse</a> <a href="/tags/Web/" style="font-size: 15px;">Web</a> <a href="/tags/https/" style="font-size: 15px;">https</a> <a href="/tags/Daily/" style="font-size: 15px;">Daily</a> <a href="/tags/DDoS/" style="font-size: 15px;">DDoS</a> <a href="/tags/Pentest/" style="font-size: 15px;">Pentest</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/11/03/白盒扫描技术综述/">白盒扫描技术简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/25/反射放大DDos/">反射放大DDoS</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/10/我的2021届校招/">我的2021届校招</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/01/轰炸漏洞小结/">浅谈轰炸漏洞攻防思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/23/HexoTheme-Optimization/">HexoTheme Optimization</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/20/CVE-2019-12136/">CVE-2019-12136</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/21/ss-NG-switchyOmega+Outline/">Shadowsocks+SwitchyOmega+Outline</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/21/HHB/">平头哥HHB</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/31/EduSRC挖洞小结/">EduSRC挖洞小结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/01/Web指纹识别/">Web指纹识别</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//Fr4nk404.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://hexo.imagemlt.xyz/" title="Imagemlt" target="_blank">Imagemlt</a><ul></ul><a href="http://blog.0kami.cn/" title="wh1t3p1g" target="_blank">wh1t3p1g</a><ul></ul><a href="http://www.recorday.cn/" title="C0d3r1iu" target="_blank">C0d3r1iu</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Fr4nk404.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" color="0,0,0" opacity="0.5" zindex="-2" count="50" src="//lib.baomitu.com/canvas-nest.js/2.0.4/canvas-nest.umd.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>